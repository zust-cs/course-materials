# Java面向对象

## 面向对象

对象：用来描述客观事物的一个实体

类：具有相同属性和方法的一组对象的集合

## 类和对象

### 定义类

```
public class 类名{
    //定义属性部分
    [访问修饰符] 数据类型 属性名；
    
    //定义方法部分
    [访问修饰符] 返回类型 方法名(参数){
    }
}
```

### 创建并引用对象

类名 对象名 = new 构造方法()；

对象名.属性

对象名.方法名()

#### 对象实例化

**实例化对象过程可分为两部分:**

-声明对象 Cat one

-实例化对象 new Cat();

-Cat one = new Cat();

## 构造方法

**1：构造方法与类同名且没有返回值**

**2：只能在对象实例化的时候调用**

**3：一个类中可以有多个构造方法**

**4：当没有指定构造方法时，系统会自动添加无参的构造方法**

**5：当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法**

```
public 构造方法名(){
    //初始化代码
}
```

## this关键字

this:当前对象的默认引用

this的使用

​     **-调用成员方法**

```
public void run(){
    this.eat();
    System.out.println("小猫快跑");
}

public void eat(){
    System.out.println("小猫吃鱼")；
}
```

​    **-调用重载的构造方法**

```
public Cat(){
    System.out.println("我是无参构造")；
}

public Cat(String name){
    this();
    this.name = name;
    System.out.println("我是单参构造");
}
```

可以在单参构造方法中，通过this()来调用同一类的无参构造方法，且必须放在第一条

# java封装

## 封装

通过对该类提供的方法来实现对隐藏信息的操作和访问

隐藏对象的信息

留出访问的接口

**特点：**

1：只能通过规定的方法访问数据

2：隐藏类的实例细节，方便修改和实现

**过程：**

1:修改属性的可见性-------设为private

2:创建getter/setter方法-------设为public，用于属性的读写

3:再getter/setter方法中加入属性控制语句-------对属性值的合法性进行判断

## 包

### 定义包

语法：

​    `package 包名；`

  注意：

​          1：必须放在Java源文件中的第一行

​          2：一个Java源文件中只能有一个package语句

​          3：包名全部英文小写

​          4：命名方式：域名倒序+模块+功能

### 导入包

语法：

   `import 包名.类名；`

   例：

​    导入包中全部类：

​    import com.imooc.*;

​    导入包中指定类：

​    import com.imooc.animal.Cat;

## static

**基本作用：**方便在没有创建对象的情况下来进行调用(没有this)

被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问

1:static+属性     ————静态属性、类属性

2:static+方法     ————静态方法、类方法

3:static+类         ————不存在静态类

4:static+方法内部局部变量      ————不存在方法中的静态局部变量

5:static+代码块

**普通代码块**：代码块存在于方法中

**构造代码块**：代码块存在于类当中

**静态代码块**：构造代码块前加上static

##### 1：静态成员的生命周期

类加载时产生，销毁时释放，生命周期长

##### 2：静态方法中的成员调用

能直接访问类内的静态成员，不能访问非静态成员

若一定要访问非静态成员，则只能通过对象实例化后，通过对象的形式去访问

##### 3：各种代码块的执行顺序

静态代码块只执行一次，构造代码块再每次对象构造的时候调用，普通代码块在每次调用方法的时候顺序调用

# Java继承

## 概念

1：一种类与类之间的关系

2：使用已存在的类的定义作为基础建立新类

3：新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性地继承父类

4：满足 “A is a B” 的关系

## 特点

1：利于代码复用

2：缩短开发周期

## 语法

1：使用extends实现继承

2：单一继承，只能有一个父类

## 初始化顺序

父类静态成员→子类静态成员→父类对象构造→子类对象构造

## super

-子类的构造的过程中必须调用其父类的构造方法，默认调用无参的构造方法

-如果子类构造方法中既没有显示标注，而父类又没有无参的构造方法，则编译出错

-使用super调用父类指定构造方法，必须在子类的构造方法的第一行

## 方法重写 PK 方法重载

**方法重写：**                                                                                              **方法重载：**

-在满足继承关系的子类中                                                                     -在同一个类中

-方法名、参数个数、顺序、返回值与父类**兼容**                                  -方法名相同

-访问修饰符的限定范围大于等于父类方法                                          -参数个数、顺序、类型不同

​                                                                                                                -返回值类型、访问修饰符任意



|  访问修饰符   | 本类 | 同包 | 子类 | 其他 |
| :-----------: | :--: | :--: | :--: | :--: |
|  **private**  |  √   |      |      |      |
|   **默认**    |  √   |  √   |      |      |
| **protected** |  √   |  √   |  √   |      |
|  **public**   |  √   |  √   |  √   |  √   |

## Object类

Object类是所有类的父类

Java中的每个类都可以使用Object中定义的方法

​      -equals()

​      -toString()

## final

#### 1：修饰类表示不允许被继承

#### 2：修饰方法表示不允许被子类重写

​        -final修饰的方法可以被继承

​        -不能修饰构造方法

#### 3：修饰变量表示不允许修改

​        -方法内部的局部变量            》          在使用之前被初始化赋值即可

​        -类中成员变量                  》              只能在定义时、构造方法、构造代码块中进行

​        -基本数据类型的变量        》    初始赋值之后不能更改

​        -引用类型的变量         》      初始化之后不能再指向另一个对象，但对象的内容是可变的

#### 4：可配合static使用

`public static final int temp = 1;`

不能被修改

#### 5：使用final修饰可以提高性能，但会降低可扩展性

## 注解

可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释

#### 按照运行机制分

1：源码注解

2：编译时注解

3：运行时注解

#### 按照来源分

1：来自JDK的注解

2：来自第三方的注解

3：我们自己定义的注解

# 单例模式

### 目的

使得类的一个对象称为该类系统中的唯一实例

### 定义

一个类有且仅有一个实例，并且自行实例化向整个系统提供

### 要点

1：某个类只能有一个实例

2：必须自行创建实例

3：必须自行向整个系统提供这个实例

### 实现

1：只提供私有的构造方法

2：含有一个该类的静态私有对象

3：提供一个静态的共有方法用于创建、获取静态私有对象

### 代码实现方案

饿汉式：对象创建过程中实例化

```
public class single {
    //创建类中私有构造
    private single(){

    }

    //创建该类型的私有静态实例
    private static single instance=new single();

    //创建公有静态方法返回静态实例对象
    public static single getInstance(){
        return instance;
    }
}
```



懒汉式：静态共有方法中实例化

```
public class singletwo {
    //1:创建私有构造方法
    private singletwo(){

    }

    //2:创建静态的该类实例对象
    private static singletwo instance=null;

    //3:创建开放的静态方法提供实例对象
    public static singletwo getInstance(){
        if(instance==null)
            instance=new singletwo();
        return  instance;
    }
}
```

# java多态

## 多态的分类

1、编译时多态（设计时多态）：方法重载

2、运行时多态：JAVA运行时系统根据调用该方法的实例的类型来决定选择调用哪个方法则被称为运行时多态

## 转型

向上类型转换（Upcast)：将子类型转换为父类型

  -隐式/自动类型转换，是小类型到大类型的转换

`Animal one=new Cat();`

向下类型转换（Downcast)：将父类型转换为子类型

 -强制类型转换，是大类型到小类型

```
Animal two=new Cat();
Cat temp=(Cat)two;
```

通过`instanceof`运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的强壮性

`if(two instanceof Cat)`

## 抽象类和抽象方法

### 抽象类

Java中使用抽象类，限制实例化

```
public abstract class Animal(){
}
```

### 抽象方法

abstract也可用于方法——抽象方法

```
public abstract void eat();
```

### 注意

1、抽象类不能直接实例化

2、子类如果没有重写父类所有的抽象方法，则也要定义为抽象类

3、抽象方法所在的类一定是抽象类

4、抽象类中可以没有抽象方法

## 接口

接口定义了某一批类所需要遵守的规范

接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法

### 注意

接口可以实现多继承，即一个子接口可以同时继承多个父接口

实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类

一个类可以继承自一个父类，同时实现多个接口

### 用法

```
public interface IPhoto{
    public void photo();
}
```

```
public class FourthPhone extends ThirdPhone implements IPhoto{
}
```

## 抽象类和接口的区别

|        参数        |                            抽象类                            |                             接口                             |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   默认的方法实现   |                    它可以有默认的方法实现                    |           接口完全是抽象的，它根本不存在方法的实现           |
|        实现        | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 |
|       构造器       |                      抽象类可以有构造器                      |                       接口不能有构造器                       |
| 与正常Java类的区别 |      除了不能实例化抽象类之外，和普通Java类没有任何区别      |                     接口是完全不同的类型                     |
|     访问修饰符     |      抽象方法可以有public、protected和default这些修饰符      |      接口方法默认修饰符是public。你不可以使用其他修饰符      |
|      main方法      |           抽象方法可以有main方法并且我们可以运行它           |             接口没有main方法，因此我们不能运行它             |
|       多继承       |             抽象方法可以继承一个类和实现多个接口             |              接口只可以继承一个或多个其他类接口              |
|        速度        |                       它比接口速度要快                       |   接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法   |
|     添加新方法     | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码 |     如果你往接口中添加方法，那么你必须改变实现该接口的类     |

## 内部类

在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类

与之对应，包含内部类的类被称为外部类

### 内部类的分类

1：成员内部类

2：静态内部类

3：方法内部类

4：匿名内部类

### 优势

内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中其他类访问该类，更好的实现了信息隐藏

### 特点

```
* 1、匿名内部类没有类型名称，实例对象名称
* 2、编译后的文件命名：外部类￥数字. class
* 3、无法使用访问修饰符修饰
* 4、无法编写构造方法，可以添加构造代码块
* 5、不能出现静态成员
* 6、匿名内部类可以实现接口，也可以继承父类，但是不可兼得
```

